<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Star Colors</title>
    <script src="//cdn.jsdelivr.net/phaser/2.2.2/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>
	<header>
		game
	</header>
	<main>
		<div id="gameholder" class="gameholder">

		</div>
	</main>
	<footer>&copy;footerauthority</footer>
	<script type="text/javascript">

	const GAME_HEIGHT = 600;

	var game = new Phaser.Game(800, GAME_HEIGHT, Phaser.AUTO, "gameholder", { preload: preload, create: create, update: update });



	function preload() {

    game.load.image("sky", "assets/space1.png");
    game.load.image("ground", "assets/platform.png");
    game.load.image("star", "assets/star.png");
		game.load.image("barrier", "assets/barrier.png");
		game.load.spritesheet("red", "assets/barrier0.png", 25, 120);
		game.load.spritesheet("orange", "assets/barrier1.png", 25, 120);
		game.load.spritesheet("yellow", "assets/barrier2.png", 25, 120);
		game.load.spritesheet("green", "assets/barrier3.png", 25, 120);
		game.load.spritesheet("blue", "assets/barrier4.png", 25, 120);
		game.load.spritesheet("purple", "assets/barrier5.png", 25, 120);
    game.load.spritesheet("dude", "assets/playerspritesall.png", 59, 29);
	}

	var numPlayers = 1
	var player1;
	var player1Stats = {
		color: 0,
		health: 3,
		score: 0,
		highScore: 0,
		powerupsAvailable: 0,
		powerupsUsed: 0
	};
	var overallHighScore;
	var numRandomBarriers = 10;
	const barrierSpawnX = 780;
	const barriersPerSpawn = 5;
	var barrierSpawnStaggerFrames = 80;
	class Barrier {
		constructor (color, xPos, yPos)
		{
			this.color = color;
			this.xPos = xPos;
			this.yPos = yPos;
		}
	};
	const barrierKillerX = -40;
	var platforms;
	// var score = 0;
	var scoreText;
	var healthText;
	var frame = 0;
	var isFlickerPlaying = false;
	var isGameOver = false;
	const COLORS = ["red", "orange", "yellow", "green", "blue", "purple"];
	const gamePhaseTitles = ["Open Space", "Hyperspace"];
	console.log(player1Stats.health);

	function create() {
		console.log("score: " + player1Stats.score);
		//  We"re going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);

    //  A simple background for our game
    game.add.sprite(0, 0, "sky");
		//  The platforms group contains the ground and the 2 ledges we can jump on
		platforms = game.add.group();

		ends = game.add.group();

		//  We will enable physics for any object that is created in this group
		platforms.enableBody = true;

		ends.enableBody = true;

		// game.add.sprite(0, 0, "barrier");


		// NOTE: bring back into the game for hyperspace modec
    // // Here we create the ground.
    // var ground = platforms.create(0, game.world.height - 64, "ground");
		//
    // //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
    // ground.scale.setTo(2, 2);
		//
    // //  This stops it from falling away when you jump on it
    // ground.body.immovable = true;

		console.log("score: " + player1Stats.score);

    ledge = platforms.create(-150, 250, "ground");
    ledge.body.immovable = true;

		// The player and its settings
    player1 = game.add.sprite(32, game.world.height - 150, "dude");

    //  We need to enable physics on the player
    game.physics.arcade.enable(player1);

		console.log("score: " + player1Stats.score);

    //  Player physics properties.
    player1.body.collideWorldBounds = true;

		console.log("score: " + player1Stats.score);

    // player movement animations
		// player1.animations.add("lateral", [1, 2], 900, true);
    player1.animations.add("lateral0", [1, 2], 900, true);
		player1.animations.add("lateral1", [7, 8], 900, true);
		player1.animations.add("lateral2", [13, 14], 900, true);
		player1.animations.add("lateral3", [19, 20], 900, true);
		player1.animations.add("lateral4", [25, 26], 900, true);
		player1.animations.add("lateral5", [31, 32], 900, true);

		player1.animations.add("flicker0", [3, 4, 5, 4, 3, 4, 5, 4, 3, 4, 5, 4, 3, 4, 5, 4, 3], 900, true);

		cursors = game.input.keyboard.createCursorKeys();

		keyDash = game.input.keyboard.addKey(Phaser.Keyboard.ONE);
    // key1.onDown.add(addPhaserDude, this);

		stars = game.add.group();

		stars.enableBody = true;

		barriers = game.add.group();

		barriers.enableBody = true;




    // //  Here we"ll create 12 of them evenly spaced apart
    // for (var i = 0; i < 12; i++)
    // {
    //     //  Create a star inside of the "stars" group
    //     var star = stars.create(i * 200, i * 30, "star");
		//
    //     //  Let gravity do its thing
    //     star.body.gravity.y = 6;
		//
    //     //  This just gives each star a slightly random bounce value
    //     star.body.bounce.y = 0.7 + Math.random() * 0.2;
    // }
		console.log("score: " + player1Stats.score);
		scoreText = game.add.text(150, 16, "score: " + player1Stats.score, { fontSize: "32px", fill: "#fff" });
		healthText = game.add.text(16, 16, "health: " + player1Stats.health, { fontSize: "32px", fill: "#fff" });
	}

	function update() {
		if (isGameOver) {
			endGame();
		} else {

		} if (currentGamePhase === 0) {
			//  Reset the players velocity (movement)
			player1.body.velocity.x = 0;
			player1.body.velocity.y = 0;

			if (cursors.left.isDown) {
				//  Move to the left
				if (keyDash.isDown) {
					player1.body.velocity.x = -350;
				} else {
					player1.body.velocity.x = -250;
				}
				if (!isFlickerPlaying) {
					player1.animations.play("lateral" + player1Stats.color);
				}
			} else if (cursors.right.isDown) {
				//  Move to the right
				if (keyDash.isDown) {
					player1.body.velocity.x = 350;
				} else {
					player1.body.velocity.x = 250;
				}
				if (!isFlickerPlaying) {
					player1.animations.play("lateral" + player1Stats.color);
				}
			} else {
				//  Stay still
				player1.frame = 0 + player1Stats.color * 6;
			}

			if (cursors.up.isDown) {
				if (keyDash.isDown) {
					player1.body.velocity.y = -350;
				} else {
					player1.body.velocity.y = -250;
				}
			} else if (cursors.down.isDown) {
				if (keyDash.isDown) {
					player1.body.velocity.y = 350;
				} else {
					player1.body.velocity.y = 250;
				}
			}

			game.physics.arcade.collide(stars, platforms);

			game.physics.arcade.overlap(player1, stars, collideStars, null, this);

			function collideStars (player1, star) {

				// Removes the star from the screen
				star.kill();

				//  Add and update the score
				player1Stats.score += 10;
				scoreText.text = "Score: " + player1Stats.score;

			}

			game.physics.arcade.overlap(player1, barriers, collideBarriers, null, this);

			function collideBarriers (player1, barrier) {
				// console.log(barrier.animations.sprite.key);
				// console.log(barrier);
				if (barrier.animations.sprite.key === COLORS[player1Stats.color]) {
					// console.log("no kill");
					barrier.animations.play("pass");
				} else {
					// console.log("collision");
					// isFlickerPlaying = true;
					player1.animations.play("flicker" + player1Stats.color);

					// Removes the star from the screen
					barrier.kill();

					// player.health = player.health - 1;
					player1Stats.health--;
					healthText.text = "health: " + player1Stats.health;

					if (!player1Stats.health) {
						//endGame
						console.log("game is over");
					}
				}
			}


			if (frame / (barrierSpawnStaggerFrames * 25)) {
				// switchGamePhases(currentGamePhase);
			}

			// creates barriers every so many frames
			if (frame % barrierSpawnStaggerFrames === 0) {
				player1Stats.score++;
				scoreText.text = "Score: " + player1Stats.score;
				// console.log(COLORS[player1Stats.color]);
				var availableColors = COLORS;
				function isNotPlayerColor(value) {
					return value !== COLORS[player1Stats.color];
				}
				var notPlayerColorArr = availableColors.filter(isNotPlayerColor);
				// console.log(notPlayerColorArr);

				var playerColorBarrierIndex = Math.round(Math.random() * (COLORS.length - (numPlayers + 1)));
				console.log(playerColorBarrierIndex);
				for (var i = 0; i < barriersPerSpawn; i++) {

					if (i === playerColorBarrierIndex) {
						console.log("i " + playerColorBarrierIndex + " color " + COLORS[player1Stats.color]);
						var barrier = new Barrier(COLORS[player1Stats.color], barrierSpawnX, i * (GAME_HEIGHT / barriersPerSpawn));
						barrier = barriers.create(barrier.xPos, barrier.yPos, barrier.color);
						barrier.body.gravity.x = -10;
						barrier.body.velocity.x = -80;
						barrier.animations.add("pass", [1], 200, true);
						// } else if (!isSameColorIn) {
						// add in condition to ensure same color isn't chosen more than once.

					} else {
						var n = Math.round(Math.random() * (notPlayerColorArr.length - 1));
						var barrier = new Barrier(notPlayerColorArr[n], barrierSpawnX, i * (GAME_HEIGHT / barriersPerSpawn));
						barrier = barriers.create(barrier.xPos, barrier.yPos, barrier.color);
						barrier.body.gravity.x = -10;
						barrier.body.velocity.x = -80;
						barrier.animations.add("pass", [1], 2000, true);
					}
				}
			}
		} else if (currentGamePhase === 1) {

		}
		frame++;

		function switchGamePhases(currentGamePhase) {
			if (currentGamePhase < gamePhases.length - 1) {
				currentGamePhase++;
			} else {
				currentGamePhase = 0;
			}
		}

	}
	</script>
</body>
</html>
